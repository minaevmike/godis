// Code generated by protoc-gen-go. DO NOT EDIT.
// source: godis.proto

/*
Package godis_proto is a generated protocol buffer package.

It is generated from these files:
	godis.proto

It has these top-level messages:
	Error
	Response
	Request
	Value
	RepeatedString
	MapString
*/
package godis_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Operation int32

const (
	Operation_Remove     Operation = 0
	Operation_Get        Operation = 1
	Operation_Set        Operation = 2
	Operation_Keys       Operation = 3
	Operation_GetByIndex Operation = 4
	Operation_GetByKey   Operation = 5
)

var Operation_name = map[int32]string{
	0: "Remove",
	1: "Get",
	2: "Set",
	3: "Keys",
	4: "GetByIndex",
	5: "GetByKey",
}
var Operation_value = map[string]int32{
	"Remove":     0,
	"Get":        1,
	"Set":        2,
	"Keys":       3,
	"GetByIndex": 4,
	"GetByKey":   5,
}

func (x Operation) String() string {
	return proto.EnumName(Operation_name, int32(x))
}
func (Operation) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Error struct {
	Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type Response struct {
	// keys would be returned in `Keys` request otherwise value will be in result
	//
	// Types that are valid to be assigned to ResponseValue:
	//	*Response_Error
	//	*Response_Value
	//	*Response_Keys
	ResponseValue isResponse_ResponseValue `protobuf_oneof:"response_value"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isResponse_ResponseValue interface {
	isResponse_ResponseValue()
}

type Response_Error struct {
	Error *Error `protobuf:"bytes,1,opt,name=error,oneof"`
}
type Response_Value struct {
	Value *Value `protobuf:"bytes,2,opt,name=value,oneof"`
}
type Response_Keys struct {
	Keys *RepeatedString `protobuf:"bytes,3,opt,name=keys,oneof"`
}

func (*Response_Error) isResponse_ResponseValue() {}
func (*Response_Value) isResponse_ResponseValue() {}
func (*Response_Keys) isResponse_ResponseValue()  {}

func (m *Response) GetResponseValue() isResponse_ResponseValue {
	if m != nil {
		return m.ResponseValue
	}
	return nil
}

func (m *Response) GetError() *Error {
	if x, ok := m.GetResponseValue().(*Response_Error); ok {
		return x.Error
	}
	return nil
}

func (m *Response) GetValue() *Value {
	if x, ok := m.GetResponseValue().(*Response_Value); ok {
		return x.Value
	}
	return nil
}

func (m *Response) GetKeys() *RepeatedString {
	if x, ok := m.GetResponseValue().(*Response_Keys); ok {
		return x.Keys
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Response) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Response_OneofMarshaler, _Response_OneofUnmarshaler, _Response_OneofSizer, []interface{}{
		(*Response_Error)(nil),
		(*Response_Value)(nil),
		(*Response_Keys)(nil),
	}
}

func _Response_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Response)
	// response_value
	switch x := m.ResponseValue.(type) {
	case *Response_Error:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case *Response_Value:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Value); err != nil {
			return err
		}
	case *Response_Keys:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Keys); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Response.ResponseValue has unexpected type %T", x)
	}
	return nil
}

func _Response_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Response)
	switch tag {
	case 1: // response_value.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.ResponseValue = &Response_Error{msg}
		return true, err
	case 2: // response_value.value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Value)
		err := b.DecodeMessage(msg)
		m.ResponseValue = &Response_Value{msg}
		return true, err
	case 3: // response_value.keys
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RepeatedString)
		err := b.DecodeMessage(msg)
		m.ResponseValue = &Response_Keys{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Response_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Response)
	// response_value
	switch x := m.ResponseValue.(type) {
	case *Response_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Response_Value:
		s := proto.Size(x.Value)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Response_Keys:
		s := proto.Size(x.Keys)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Request struct {
	Key       string    `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Operation Operation `protobuf:"varint,2,opt,name=operation,enum=godis_proto.Operation" json:"operation,omitempty"`
	// value usefull only on set
	Value *Value `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	// index usefull only on get by index
	Index uint32 `protobuf:"varint,4,opt,name=index" json:"index,omitempty"`
	// map_key usefull only on get by key
	MapKey string `protobuf:"bytes,5,opt,name=map_key,json=mapKey" json:"map_key,omitempty"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (m *Request) String() string            { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Request) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Request) GetOperation() Operation {
	if m != nil {
		return m.Operation
	}
	return Operation_Remove
}

func (m *Request) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Request) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Request) GetMapKey() string {
	if m != nil {
		return m.MapKey
	}
	return ""
}

type Value struct {
	// Types that are valid to be assigned to Value:
	//	*Value_StringVal
	//	*Value_StringSlice
	//	*Value_StringMap
	Value isValue_Value `protobuf_oneof:"value"`
	// unix nanoseconds until this value is valid
	Ttl int64 `protobuf:"varint,4,opt,name=ttl" json:"ttl,omitempty"`
}

func (m *Value) Reset()                    { *m = Value{} }
func (m *Value) String() string            { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()               {}
func (*Value) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isValue_Value interface {
	isValue_Value()
}

type Value_StringVal struct {
	StringVal string `protobuf:"bytes,1,opt,name=string_val,json=stringVal,oneof"`
}
type Value_StringSlice struct {
	StringSlice *RepeatedString `protobuf:"bytes,2,opt,name=string_slice,json=stringSlice,oneof"`
}
type Value_StringMap struct {
	StringMap *MapString `protobuf:"bytes,3,opt,name=string_map,json=stringMap,oneof"`
}

func (*Value_StringVal) isValue_Value()   {}
func (*Value_StringSlice) isValue_Value() {}
func (*Value_StringMap) isValue_Value()   {}

func (m *Value) GetValue() isValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Value) GetStringVal() string {
	if x, ok := m.GetValue().(*Value_StringVal); ok {
		return x.StringVal
	}
	return ""
}

func (m *Value) GetStringSlice() *RepeatedString {
	if x, ok := m.GetValue().(*Value_StringSlice); ok {
		return x.StringSlice
	}
	return nil
}

func (m *Value) GetStringMap() *MapString {
	if x, ok := m.GetValue().(*Value_StringMap); ok {
		return x.StringMap
	}
	return nil
}

func (m *Value) GetTtl() int64 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Value) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Value_OneofMarshaler, _Value_OneofUnmarshaler, _Value_OneofSizer, []interface{}{
		(*Value_StringVal)(nil),
		(*Value_StringSlice)(nil),
		(*Value_StringMap)(nil),
	}
}

func _Value_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Value)
	// value
	switch x := m.Value.(type) {
	case *Value_StringVal:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.StringVal)
	case *Value_StringSlice:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StringSlice); err != nil {
			return err
		}
	case *Value_StringMap:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StringMap); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Value.Value has unexpected type %T", x)
	}
	return nil
}

func _Value_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Value)
	switch tag {
	case 1: // value.string_val
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &Value_StringVal{x}
		return true, err
	case 2: // value.string_slice
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RepeatedString)
		err := b.DecodeMessage(msg)
		m.Value = &Value_StringSlice{msg}
		return true, err
	case 3: // value.string_map
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MapString)
		err := b.DecodeMessage(msg)
		m.Value = &Value_StringMap{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Value_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Value)
	// value
	switch x := m.Value.(type) {
	case *Value_StringVal:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.StringVal)))
		n += len(x.StringVal)
	case *Value_StringSlice:
		s := proto.Size(x.StringSlice)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Value_StringMap:
		s := proto.Size(x.StringMap)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RepeatedString struct {
	StringArrayVal []string `protobuf:"bytes,2,rep,name=string_array_val,json=stringArrayVal" json:"string_array_val,omitempty"`
}

func (m *RepeatedString) Reset()                    { *m = RepeatedString{} }
func (m *RepeatedString) String() string            { return proto.CompactTextString(m) }
func (*RepeatedString) ProtoMessage()               {}
func (*RepeatedString) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *RepeatedString) GetStringArrayVal() []string {
	if m != nil {
		return m.StringArrayVal
	}
	return nil
}

type MapString struct {
	StringMap map[string]string `protobuf:"bytes,1,rep,name=string_map,json=stringMap" json:"string_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *MapString) Reset()                    { *m = MapString{} }
func (m *MapString) String() string            { return proto.CompactTextString(m) }
func (*MapString) ProtoMessage()               {}
func (*MapString) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *MapString) GetStringMap() map[string]string {
	if m != nil {
		return m.StringMap
	}
	return nil
}

func init() {
	proto.RegisterType((*Error)(nil), "godis_proto.Error")
	proto.RegisterType((*Response)(nil), "godis_proto.Response")
	proto.RegisterType((*Request)(nil), "godis_proto.Request")
	proto.RegisterType((*Value)(nil), "godis_proto.Value")
	proto.RegisterType((*RepeatedString)(nil), "godis_proto.RepeatedString")
	proto.RegisterType((*MapString)(nil), "godis_proto.MapString")
	proto.RegisterEnum("godis_proto.Operation", Operation_name, Operation_value)
}

func init() { proto.RegisterFile("godis.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 473 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x92, 0xdf, 0x8a, 0xd3, 0x40,
	0x14, 0xc6, 0x3b, 0x4d, 0xd3, 0x36, 0xa7, 0x6b, 0x08, 0x87, 0x45, 0x83, 0x5e, 0x58, 0x03, 0x42,
	0xd8, 0x8b, 0x82, 0x55, 0x50, 0x16, 0x2f, 0xb4, 0xb8, 0x6c, 0xa5, 0x2c, 0xe2, 0x14, 0x7a, 0x5b,
	0x46, 0x7b, 0x28, 0x61, 0xf3, 0xcf, 0x99, 0xd9, 0xc5, 0x3c, 0x85, 0x8f, 0x21, 0xf8, 0x10, 0x3e,
	0x9b, 0xcc, 0x24, 0xa9, 0x0d, 0x54, 0xbc, 0x9b, 0x33, 0xf3, 0x3b, 0xf3, 0x7d, 0xdf, 0x99, 0x81,
	0xc9, 0xbe, 0xd8, 0x25, 0x6a, 0x56, 0xca, 0x42, 0x17, 0x58, 0x17, 0x5b, 0x5b, 0x44, 0xcf, 0xc0,
	0xbd, 0x92, 0xb2, 0x90, 0x18, 0xc2, 0x28, 0x23, 0xa5, 0xc4, 0x9e, 0x42, 0x36, 0x65, 0xb1, 0xc7,
	0xdb, 0x32, 0xfa, 0xc9, 0x60, 0xcc, 0x49, 0x95, 0x45, 0xae, 0x08, 0x2f, 0xc0, 0x25, 0xc3, 0x5b,
	0x68, 0x32, 0xc7, 0xd9, 0xd1, 0x65, 0x33, 0x7b, 0xd3, 0xb2, 0xc7, 0x6b, 0xc4, 0xb0, 0xf7, 0x22,
	0xbd, 0xa3, 0xb0, 0x7f, 0x82, 0xdd, 0x98, 0x13, 0xc3, 0x5a, 0x04, 0x5f, 0xc0, 0xe0, 0x96, 0x2a,
	0x15, 0x3a, 0x16, 0x7d, 0xd2, 0x41, 0x39, 0x95, 0x24, 0x34, 0xed, 0xd6, 0x5a, 0x26, 0xf9, 0x7e,
	0xd9, 0xe3, 0x16, 0x5d, 0x04, 0xe0, 0xcb, 0xc6, 0xd6, 0xd6, 0x5e, 0x12, 0xfd, 0x62, 0x30, 0xe2,
	0xf4, 0xed, 0x8e, 0x94, 0xc6, 0x00, 0x9c, 0x5b, 0xaa, 0x9a, 0x2c, 0x66, 0x89, 0xaf, 0xc0, 0x2b,
	0x4a, 0x92, 0x42, 0x27, 0x45, 0x6e, 0x2d, 0xf9, 0xf3, 0x87, 0x1d, 0x9d, 0x4f, 0xed, 0x29, 0xff,
	0x0b, 0x62, 0xdc, 0x86, 0x70, 0xfe, 0x15, 0xa2, 0x8d, 0x70, 0x0e, 0x6e, 0x92, 0xef, 0xe8, 0x7b,
	0x38, 0x98, 0xb2, 0xf8, 0x01, 0xaf, 0x0b, 0x7c, 0x04, 0xa3, 0x4c, 0x94, 0x5b, 0xe3, 0xc5, 0xb5,
	0x5e, 0x86, 0x99, 0x28, 0x57, 0x54, 0x45, 0xbf, 0x19, 0xb8, 0xb6, 0x1f, 0x9f, 0x02, 0x28, 0x1b,
	0xcd, 0xc4, 0xa8, 0x1d, 0x2f, 0x7b, 0xdc, 0xab, 0xf7, 0x36, 0x22, 0xc5, 0x77, 0x70, 0xd6, 0x00,
	0x2a, 0x4d, 0xbe, 0xb6, 0xf3, 0xfc, 0xcf, 0x90, 0x26, 0x75, 0xcb, 0xda, 0x74, 0xe0, 0xeb, 0x83,
	0x44, 0x26, 0xca, 0x26, 0x4a, 0x37, 0xfc, 0x8d, 0x28, 0x0f, 0xad, 0x8d, 0xf4, 0x8d, 0x28, 0xcd,
	0x18, 0xb5, 0x4e, 0x6d, 0x24, 0x87, 0x9b, 0xe5, 0x62, 0xd4, 0x0c, 0x24, 0xba, 0x04, 0xbf, 0x2b,
	0x8a, 0x31, 0x04, 0x8d, 0x8a, 0x90, 0x52, 0x54, 0x36, 0x4e, 0x7f, 0xea, 0xc4, 0x1e, 0xf7, 0xeb,
	0xfd, 0xf7, 0x66, 0x7b, 0x23, 0xd2, 0xe8, 0x07, 0x03, 0xef, 0xa0, 0x88, 0x1f, 0x3a, 0xee, 0xd8,
	0xd4, 0x89, 0x27, 0xf3, 0xe7, 0xa7, 0xdd, 0xcd, 0xd6, 0xad, 0xb5, 0xab, 0x5c, 0xcb, 0xea, 0xc8,
	0xea, 0xe3, 0xb7, 0xe0, 0x77, 0x0f, 0x4f, 0xfc, 0x81, 0xf3, 0xe3, 0x2f, 0xe9, 0x35, 0x2f, 0x77,
	0xd9, 0x7f, 0xc3, 0x2e, 0x3e, 0x83, 0x77, 0x78, 0x7f, 0x04, 0x18, 0x72, 0xca, 0x8a, 0x7b, 0x0a,
	0x7a, 0x38, 0x02, 0xe7, 0x9a, 0x74, 0xc0, 0xcc, 0x62, 0x4d, 0x3a, 0xe8, 0xe3, 0x18, 0x06, 0x2b,
	0xaa, 0x54, 0xe0, 0xa0, 0x0f, 0x70, 0x4d, 0x7a, 0x51, 0x7d, 0x34, 0x4f, 0x1d, 0x0c, 0xf0, 0x0c,
	0xc6, 0xb6, 0x5e, 0x51, 0x15, 0xb8, 0x5f, 0x86, 0xd6, 0xfb, 0xcb, 0x3f, 0x01, 0x00, 0x00, 0xff,
	0xff, 0x31, 0x96, 0x2b, 0x92, 0x7e, 0x03, 0x00, 0x00,
}
